// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/telemetry.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SystemInfo struct {
	Os                   string   `protobuf:"bytes,1,opt,name=os,proto3" json:"os,omitempty"`
	Arch                 string   `protobuf:"bytes,2,opt,name=arch,proto3" json:"arch,omitempty"`
	Numcpu               uint32   `protobuf:"varint,3,opt,name=numcpu,proto3" json:"numcpu,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SystemInfo) Reset()         { *m = SystemInfo{} }
func (m *SystemInfo) String() string { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()    {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{0}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(m, src)
}
func (m *SystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

func (m *SystemInfo) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *SystemInfo) GetArch() string {
	if m != nil {
		return m.Arch
	}
	return ""
}

func (m *SystemInfo) GetNumcpu() uint32 {
	if m != nil {
		return m.Numcpu
	}
	return 0
}

type ProviderRecord struct {
	Key                  []byte           `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Peer                 []byte           `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	LastRefresh          *types.Timestamp `protobuf:"bytes,3,opt,name=last_refresh,json=lastRefresh,proto3" json:"last_refresh,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ProviderRecord) Reset()         { *m = ProviderRecord{} }
func (m *ProviderRecord) String() string { return proto.CompactTextString(m) }
func (*ProviderRecord) ProtoMessage()    {}
func (*ProviderRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{1}
}
func (m *ProviderRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderRecord.Merge(m, src)
}
func (m *ProviderRecord) XXX_Size() int {
	return m.Size()
}
func (m *ProviderRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderRecord proto.InternalMessageInfo

func (m *ProviderRecord) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ProviderRecord) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *ProviderRecord) GetLastRefresh() *types.Timestamp {
	if m != nil {
		return m.LastRefresh
	}
	return nil
}

type TelemetryDebug struct {
	Timestamp            *types.Timestamp         `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Streams              []*TelemetryDebug_Stream `protobuf:"bytes,2,rep,name=streams,proto3" json:"streams,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TelemetryDebug) Reset()         { *m = TelemetryDebug{} }
func (m *TelemetryDebug) String() string { return proto.CompactTextString(m) }
func (*TelemetryDebug) ProtoMessage()    {}
func (*TelemetryDebug) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{2}
}
func (m *TelemetryDebug) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryDebug) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryDebug.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryDebug) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryDebug.Merge(m, src)
}
func (m *TelemetryDebug) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryDebug) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryDebug.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryDebug proto.InternalMessageInfo

func (m *TelemetryDebug) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TelemetryDebug) GetStreams() []*TelemetryDebug_Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

type TelemetryDebug_Stream struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Used                 uint32   `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Total                uint32   `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TelemetryDebug_Stream) Reset()         { *m = TelemetryDebug_Stream{} }
func (m *TelemetryDebug_Stream) String() string { return proto.CompactTextString(m) }
func (*TelemetryDebug_Stream) ProtoMessage()    {}
func (*TelemetryDebug_Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{2, 0}
}
func (m *TelemetryDebug_Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryDebug_Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryDebug_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryDebug_Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryDebug_Stream.Merge(m, src)
}
func (m *TelemetryDebug_Stream) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryDebug_Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryDebug_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryDebug_Stream proto.InternalMessageInfo

func (m *TelemetryDebug_Stream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TelemetryDebug_Stream) GetUsed() uint32 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *TelemetryDebug_Stream) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type StreamSegment struct {
	Seqn                 uint32   `protobuf:"varint,1,opt,name=seqn,proto3" json:"seqn,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamSegment) Reset()         { *m = StreamSegment{} }
func (m *StreamSegment) String() string { return proto.CompactTextString(m) }
func (*StreamSegment) ProtoMessage()    {}
func (*StreamSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{3}
}
func (m *StreamSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamSegment.Merge(m, src)
}
func (m *StreamSegment) XXX_Size() int {
	return m.Size()
}
func (m *StreamSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamSegment.DiscardUnknown(m)
}

var xxx_messageInfo_StreamSegment proto.InternalMessageInfo

func (m *StreamSegment) GetSeqn() uint32 {
	if m != nil {
		return m.Seqn
	}
	return 0
}

func (m *StreamSegment) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetSessionInfoResponse struct {
	Session              string           `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
	BootTime             *types.Timestamp `protobuf:"bytes,2,opt,name=boot_time,json=bootTime,proto3" json:"boot_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetSessionInfoResponse) Reset()         { *m = GetSessionInfoResponse{} }
func (m *GetSessionInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetSessionInfoResponse) ProtoMessage()    {}
func (*GetSessionInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{4}
}
func (m *GetSessionInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSessionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSessionInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSessionInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSessionInfoResponse.Merge(m, src)
}
func (m *GetSessionInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSessionInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSessionInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSessionInfoResponse proto.InternalMessageInfo

func (m *GetSessionInfoResponse) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *GetSessionInfoResponse) GetBootTime() *types.Timestamp {
	if m != nil {
		return m.BootTime
	}
	return nil
}

type GetAvailableStreamsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAvailableStreamsRequest) Reset()         { *m = GetAvailableStreamsRequest{} }
func (m *GetAvailableStreamsRequest) String() string { return proto.CompactTextString(m) }
func (*GetAvailableStreamsRequest) ProtoMessage()    {}
func (*GetAvailableStreamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{5}
}
func (m *GetAvailableStreamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAvailableStreamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAvailableStreamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAvailableStreamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAvailableStreamsRequest.Merge(m, src)
}
func (m *GetAvailableStreamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAvailableStreamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAvailableStreamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAvailableStreamsRequest proto.InternalMessageInfo

type AvailableStream struct {
	Name                 string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Period               *types.Duration `protobuf:"bytes,2,opt,name=period,proto3" json:"period,omitempty"`
	Encoding             string          `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AvailableStream) Reset()         { *m = AvailableStream{} }
func (m *AvailableStream) String() string { return proto.CompactTextString(m) }
func (*AvailableStream) ProtoMessage()    {}
func (*AvailableStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{6}
}
func (m *AvailableStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailableStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvailableStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvailableStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailableStream.Merge(m, src)
}
func (m *AvailableStream) XXX_Size() int {
	return m.Size()
}
func (m *AvailableStream) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailableStream.DiscardUnknown(m)
}

var xxx_messageInfo_AvailableStream proto.InternalMessageInfo

func (m *AvailableStream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvailableStream) GetPeriod() *types.Duration {
	if m != nil {
		return m.Period
	}
	return nil
}

func (m *AvailableStream) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

type GetStreamRequest struct {
	// name of the stream
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// starting sequence number
	Seqn uint32 `protobuf:"varint,2,opt,name=seqn,proto3" json:"seqn,omitempty"`
	// 0 = end after there are no more segments to return
	// 1 = keep alive and stream more segments as they are created
	Keepalive            uint32   `protobuf:"varint,3,opt,name=keepalive,proto3" json:"keepalive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStreamRequest) Reset()         { *m = GetStreamRequest{} }
func (m *GetStreamRequest) String() string { return proto.CompactTextString(m) }
func (*GetStreamRequest) ProtoMessage()    {}
func (*GetStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{7}
}
func (m *GetStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStreamRequest.Merge(m, src)
}
func (m *GetStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStreamRequest proto.InternalMessageInfo

func (m *GetStreamRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *GetStreamRequest) GetSeqn() uint32 {
	if m != nil {
		return m.Seqn
	}
	return 0
}

func (m *GetStreamRequest) GetKeepalive() uint32 {
	if m != nil {
		return m.Keepalive
	}
	return 0
}

type GetAvailablePropertiesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAvailablePropertiesRequest) Reset()         { *m = GetAvailablePropertiesRequest{} }
func (m *GetAvailablePropertiesRequest) String() string { return proto.CompactTextString(m) }
func (*GetAvailablePropertiesRequest) ProtoMessage()    {}
func (*GetAvailablePropertiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{8}
}
func (m *GetAvailablePropertiesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAvailablePropertiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAvailablePropertiesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAvailablePropertiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAvailablePropertiesRequest.Merge(m, src)
}
func (m *GetAvailablePropertiesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAvailablePropertiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAvailablePropertiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAvailablePropertiesRequest proto.InternalMessageInfo

type AvailableProperty struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Encoding             string   `protobuf:"bytes,2,opt,name=encoding,proto3" json:"encoding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AvailableProperty) Reset()         { *m = AvailableProperty{} }
func (m *AvailableProperty) String() string { return proto.CompactTextString(m) }
func (*AvailableProperty) ProtoMessage()    {}
func (*AvailableProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{9}
}
func (m *AvailableProperty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailableProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvailableProperty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvailableProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailableProperty.Merge(m, src)
}
func (m *AvailableProperty) XXX_Size() int {
	return m.Size()
}
func (m *AvailableProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailableProperty.DiscardUnknown(m)
}

var xxx_messageInfo_AvailableProperty proto.InternalMessageInfo

func (m *AvailableProperty) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvailableProperty) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

type GetPropertyRequest struct {
	// name of the property
	Property             string   `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPropertyRequest) Reset()         { *m = GetPropertyRequest{} }
func (m *GetPropertyRequest) String() string { return proto.CompactTextString(m) }
func (*GetPropertyRequest) ProtoMessage()    {}
func (*GetPropertyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{10}
}
func (m *GetPropertyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPropertyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPropertyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPropertyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPropertyRequest.Merge(m, src)
}
func (m *GetPropertyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPropertyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPropertyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPropertyRequest proto.InternalMessageInfo

func (m *GetPropertyRequest) GetProperty() string {
	if m != nil {
		return m.Property
	}
	return ""
}

type PropertySegment struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertySegment) Reset()         { *m = PropertySegment{} }
func (m *PropertySegment) String() string { return proto.CompactTextString(m) }
func (*PropertySegment) ProtoMessage()    {}
func (*PropertySegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_32310995d0f6af31, []int{11}
}
func (m *PropertySegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertySegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertySegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertySegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertySegment.Merge(m, src)
}
func (m *PropertySegment) XXX_Size() int {
	return m.Size()
}
func (m *PropertySegment) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertySegment.DiscardUnknown(m)
}

var xxx_messageInfo_PropertySegment proto.InternalMessageInfo

func (m *PropertySegment) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*SystemInfo)(nil), "telemetry.SystemInfo")
	proto.RegisterType((*ProviderRecord)(nil), "telemetry.ProviderRecord")
	proto.RegisterType((*TelemetryDebug)(nil), "telemetry.TelemetryDebug")
	proto.RegisterType((*TelemetryDebug_Stream)(nil), "telemetry.TelemetryDebug.Stream")
	proto.RegisterType((*StreamSegment)(nil), "telemetry.StreamSegment")
	proto.RegisterType((*GetSessionInfoResponse)(nil), "telemetry.GetSessionInfoResponse")
	proto.RegisterType((*GetAvailableStreamsRequest)(nil), "telemetry.GetAvailableStreamsRequest")
	proto.RegisterType((*AvailableStream)(nil), "telemetry.AvailableStream")
	proto.RegisterType((*GetStreamRequest)(nil), "telemetry.GetStreamRequest")
	proto.RegisterType((*GetAvailablePropertiesRequest)(nil), "telemetry.GetAvailablePropertiesRequest")
	proto.RegisterType((*AvailableProperty)(nil), "telemetry.AvailableProperty")
	proto.RegisterType((*GetPropertyRequest)(nil), "telemetry.GetPropertyRequest")
	proto.RegisterType((*PropertySegment)(nil), "telemetry.PropertySegment")
}

func init() { proto.RegisterFile("pb/telemetry.proto", fileDescriptor_32310995d0f6af31) }

var fileDescriptor_32310995d0f6af31 = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdd, 0x4e, 0xdb, 0x48,
	0x14, 0x96, 0x03, 0x1b, 0xe2, 0x13, 0x12, 0xd8, 0xd9, 0x5d, 0x14, 0x4c, 0x08, 0x59, 0x4b, 0x48,
	0x51, 0x2f, 0x9c, 0x94, 0xa2, 0x52, 0x55, 0xa2, 0x52, 0x5b, 0xda, 0xf4, 0xe7, 0x06, 0x39, 0x5c,
	0xa1, 0x4a, 0xc8, 0x8e, 0x0f, 0xc1, 0x22, 0xf6, 0x18, 0xcf, 0x18, 0x29, 0x8f, 0xd4, 0x37, 0xe9,
	0x55, 0xd5, 0x47, 0xa8, 0x78, 0x92, 0x6a, 0xc6, 0x63, 0xc7, 0x31, 0x09, 0x77, 0xe7, 0xcf, 0xdf,
	0x9c, 0xf3, 0x9d, 0x6f, 0xc6, 0x40, 0x22, 0xb7, 0xcf, 0x71, 0x8a, 0x01, 0xf2, 0x78, 0x66, 0x45,
	0x31, 0xe5, 0x94, 0xe8, 0x79, 0xc0, 0xd8, 0x9b, 0x50, 0x3a, 0x99, 0x62, 0x5f, 0x26, 0xdc, 0xe4,
	0xba, 0x8f, 0x41, 0xc4, 0x55, 0x9d, 0xd1, 0x29, 0x27, 0xbd, 0x24, 0x76, 0xb8, 0x4f, 0x43, 0x95,
	0x3f, 0x28, 0xe7, 0xb9, 0x1f, 0x20, 0xe3, 0x4e, 0x10, 0xa5, 0x05, 0xe6, 0x27, 0x80, 0xd1, 0x8c,
	0x71, 0x0c, 0x3e, 0x87, 0xd7, 0x94, 0x34, 0xa1, 0x42, 0x59, 0x4b, 0xeb, 0x6a, 0x3d, 0xdd, 0xae,
	0x50, 0x46, 0x08, 0xac, 0x3b, 0xf1, 0xf8, 0xa6, 0x55, 0x91, 0x11, 0x69, 0x93, 0x1d, 0xa8, 0x86,
	0x49, 0x30, 0x8e, 0x92, 0xd6, 0x5a, 0x57, 0xeb, 0x35, 0x6c, 0xe5, 0x99, 0x09, 0x34, 0xcf, 0x63,
	0x7a, 0xef, 0x7b, 0x18, 0xdb, 0x38, 0xa6, 0xb1, 0x47, 0xb6, 0x61, 0xed, 0x16, 0x67, 0x12, 0x6e,
	0xd3, 0x16, 0xa6, 0xc0, 0x8b, 0x10, 0x63, 0x89, 0xb7, 0x69, 0x4b, 0x9b, 0x9c, 0xc2, 0xe6, 0xd4,
	0x61, 0xfc, 0x2a, 0xc6, 0xeb, 0x18, 0xd9, 0x8d, 0x44, 0xad, 0x1f, 0x19, 0x56, 0xda, 0xb9, 0x95,
	0x75, 0x6e, 0x5d, 0x64, 0x9d, 0xdb, 0x75, 0x51, 0x6f, 0xa7, 0xe5, 0xe6, 0x4f, 0x0d, 0x9a, 0x17,
	0x19, 0x59, 0x67, 0xe8, 0x26, 0x13, 0xf2, 0x0a, 0xf4, 0x7c, 0x4c, 0x79, 0xfa, 0xd3, 0x70, 0xf3,
	0x62, 0xf2, 0x1a, 0x36, 0x18, 0x8f, 0xd1, 0x09, 0x58, 0xab, 0xd2, 0x5d, 0xeb, 0xd5, 0x8f, 0xba,
	0xd6, 0x7c, 0x33, 0x8b, 0xa7, 0x58, 0x23, 0x59, 0x68, 0x67, 0x1f, 0x18, 0x1f, 0xa1, 0x9a, 0x86,
	0xc4, 0x94, 0xa1, 0x13, 0xa0, 0xe2, 0x51, 0xda, 0x22, 0x96, 0x30, 0xf4, 0xe4, 0xe4, 0x0d, 0x5b,
	0xda, 0xe4, 0x5f, 0xf8, 0x8b, 0x53, 0xee, 0x4c, 0x15, 0x91, 0xa9, 0x63, 0x9e, 0x40, 0x23, 0xc5,
	0x19, 0xe1, 0x24, 0xc0, 0x90, 0x8b, 0x4f, 0x19, 0xde, 0x85, 0x12, 0xae, 0x61, 0x4b, 0x5b, 0xc4,
	0x3c, 0x87, 0x3b, 0x19, 0x91, 0xc2, 0x36, 0x6f, 0x61, 0x67, 0x88, 0x7c, 0x84, 0x8c, 0xf9, 0x34,
	0x14, 0xeb, 0xb4, 0x91, 0x45, 0x34, 0x64, 0x48, 0x5a, 0xb0, 0xc1, 0xd2, 0xb0, 0xea, 0x29, 0x73,
	0xc9, 0x09, 0xe8, 0x2e, 0xa5, 0xfc, 0x4a, 0x50, 0x20, 0xc1, 0x9e, 0xa6, 0xaa, 0x26, 0x8a, 0x85,
	0x6b, 0xb6, 0xc1, 0x18, 0x22, 0x7f, 0x7b, 0xef, 0xf8, 0x53, 0xc7, 0x9d, 0x62, 0xda, 0x31, 0xb3,
	0xf1, 0x2e, 0x41, 0xc6, 0x4d, 0x0e, 0x5b, 0xa5, 0xd4, 0x52, 0x52, 0x9e, 0x43, 0x35, 0xc2, 0xd8,
	0xa7, 0x9e, 0x3a, 0x7a, 0xf7, 0xd1, 0xd1, 0x67, 0x4a, 0xce, 0xb6, 0x2a, 0x24, 0x06, 0xd4, 0x30,
	0x1c, 0x53, 0xcf, 0x0f, 0x27, 0x92, 0x36, 0xdd, 0xce, 0x7d, 0xf3, 0x1b, 0x6c, 0x0b, 0x02, 0xd2,
	0xbd, 0xa4, 0x9d, 0x08, 0xb5, 0xa6, 0x0b, 0x52, 0x07, 0x2b, 0x2f, 0x27, 0xb5, 0x52, 0x20, 0xb5,
	0x0d, 0xfa, 0x2d, 0x62, 0xe4, 0x4c, 0xfd, 0x7b, 0x54, 0x3b, 0x99, 0x07, 0xcc, 0x03, 0xd8, 0x2f,
	0x4e, 0x7c, 0x1e, 0xd3, 0x08, 0x63, 0xee, 0x63, 0x3e, 0xf4, 0x7b, 0xf8, 0xbb, 0x9c, 0x9d, 0x2d,
	0x1d, 0xbb, 0x38, 0x43, 0xa5, 0x34, 0xc3, 0x00, 0xc8, 0x10, 0x79, 0xf6, 0x79, 0x36, 0x85, 0x01,
	0xb5, 0x48, 0x85, 0x14, 0x52, 0xee, 0x9b, 0x87, 0xb0, 0x95, 0x95, 0x17, 0x14, 0x23, 0xd5, 0xa1,
	0xcd, 0xd5, 0x71, 0xf4, 0x7d, 0x1d, 0xf4, 0x5c, 0xc1, 0xe4, 0x2b, 0x34, 0x17, 0xb5, 0x42, 0x76,
	0x1e, 0x71, 0xff, 0x41, 0xbc, 0x33, 0xc6, 0xff, 0x85, 0x1b, 0xb0, 0x42, 0x5e, 0x6f, 0xa0, 0x21,
	0x32, 0xf3, 0x67, 0x64, 0x15, 0xd6, 0x7f, 0x05, 0xac, 0x42, 0xf9, 0x25, 0xfc, 0xb3, 0x44, 0x4b,
	0xe4, 0x70, 0xf1, 0xe4, 0x15, 0x5a, 0x33, 0x8c, 0x42, 0x59, 0xa9, 0x66, 0xa0, 0x91, 0x33, 0xd0,
	0x73, 0x4d, 0x90, 0xbd, 0xd2, 0x2c, 0x45, 0xa5, 0x18, 0xad, 0x62, 0x73, 0xc5, 0x0b, 0x38, 0xd0,
	0x88, 0x2b, 0xaf, 0xd6, 0x92, 0xdd, 0x93, 0xde, 0x8a, 0x26, 0x1f, 0xc9, 0xc3, 0x68, 0x2f, 0xeb,
	0x33, 0xdb, 0xdc, 0x40, 0x23, 0x5f, 0xa0, 0x5e, 0xd8, 0x3c, 0xd9, 0x5f, 0x04, 0x2e, 0x29, 0x62,
	0x61, 0xea, 0xd2, 0xfa, 0x07, 0x1a, 0x39, 0x85, 0xda, 0x10, 0x79, 0xfa, 0x1a, 0xae, 0x5a, 0xc6,
	0xee, 0xca, 0xa7, 0xed, 0xdd, 0xb3, 0x1f, 0x0f, 0x1d, 0xed, 0xd7, 0x43, 0x47, 0xfb, 0xfd, 0xd0,
	0xd1, 0x2e, 0xdb, 0x13, 0x9f, 0x5b, 0xde, 0xf1, 0xcb, 0x63, 0x8b, 0xdd, 0xf4, 0x93, 0xd0, 0x9f,
	0xff, 0xac, 0xfa, 0x91, 0xeb, 0x56, 0x25, 0xec, 0x8b, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2b,
	0x99, 0xae, 0xcd, 0xc6, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TelemetryClient is the client API for Telemetry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TelemetryClient interface {
	GetSessionInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetSessionInfoResponse, error)
	GetSystemInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SystemInfo, error)
	GetAvailableStreams(ctx context.Context, in *GetAvailableStreamsRequest, opts ...grpc.CallOption) (Telemetry_GetAvailableStreamsClient, error)
	GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (Telemetry_GetStreamClient, error)
	GetAvailableProperties(ctx context.Context, in *GetAvailablePropertiesRequest, opts ...grpc.CallOption) (Telemetry_GetAvailablePropertiesClient, error)
	GetProperty(ctx context.Context, in *GetPropertyRequest, opts ...grpc.CallOption) (Telemetry_GetPropertyClient, error)
	GetDebug(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*TelemetryDebug, error)
}

type telemetryClient struct {
	cc *grpc.ClientConn
}

func NewTelemetryClient(cc *grpc.ClientConn) TelemetryClient {
	return &telemetryClient{cc}
}

func (c *telemetryClient) GetSessionInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetSessionInfoResponse, error) {
	out := new(GetSessionInfoResponse)
	err := c.cc.Invoke(ctx, "/telemetry.Telemetry/GetSessionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) GetSystemInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SystemInfo, error) {
	out := new(SystemInfo)
	err := c.cc.Invoke(ctx, "/telemetry.Telemetry/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) GetAvailableStreams(ctx context.Context, in *GetAvailableStreamsRequest, opts ...grpc.CallOption) (Telemetry_GetAvailableStreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Telemetry_serviceDesc.Streams[0], "/telemetry.Telemetry/GetAvailableStreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &telemetryGetAvailableStreamsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Telemetry_GetAvailableStreamsClient interface {
	Recv() (*AvailableStream, error)
	grpc.ClientStream
}

type telemetryGetAvailableStreamsClient struct {
	grpc.ClientStream
}

func (x *telemetryGetAvailableStreamsClient) Recv() (*AvailableStream, error) {
	m := new(AvailableStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *telemetryClient) GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (Telemetry_GetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Telemetry_serviceDesc.Streams[1], "/telemetry.Telemetry/GetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &telemetryGetStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Telemetry_GetStreamClient interface {
	Recv() (*StreamSegment, error)
	grpc.ClientStream
}

type telemetryGetStreamClient struct {
	grpc.ClientStream
}

func (x *telemetryGetStreamClient) Recv() (*StreamSegment, error) {
	m := new(StreamSegment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *telemetryClient) GetAvailableProperties(ctx context.Context, in *GetAvailablePropertiesRequest, opts ...grpc.CallOption) (Telemetry_GetAvailablePropertiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Telemetry_serviceDesc.Streams[2], "/telemetry.Telemetry/GetAvailableProperties", opts...)
	if err != nil {
		return nil, err
	}
	x := &telemetryGetAvailablePropertiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Telemetry_GetAvailablePropertiesClient interface {
	Recv() (*AvailableProperty, error)
	grpc.ClientStream
}

type telemetryGetAvailablePropertiesClient struct {
	grpc.ClientStream
}

func (x *telemetryGetAvailablePropertiesClient) Recv() (*AvailableProperty, error) {
	m := new(AvailableProperty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *telemetryClient) GetProperty(ctx context.Context, in *GetPropertyRequest, opts ...grpc.CallOption) (Telemetry_GetPropertyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Telemetry_serviceDesc.Streams[3], "/telemetry.Telemetry/GetProperty", opts...)
	if err != nil {
		return nil, err
	}
	x := &telemetryGetPropertyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Telemetry_GetPropertyClient interface {
	Recv() (*PropertySegment, error)
	grpc.ClientStream
}

type telemetryGetPropertyClient struct {
	grpc.ClientStream
}

func (x *telemetryGetPropertyClient) Recv() (*PropertySegment, error) {
	m := new(PropertySegment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *telemetryClient) GetDebug(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*TelemetryDebug, error) {
	out := new(TelemetryDebug)
	err := c.cc.Invoke(ctx, "/telemetry.Telemetry/GetDebug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TelemetryServer is the server API for Telemetry service.
type TelemetryServer interface {
	GetSessionInfo(context.Context, *types.Empty) (*GetSessionInfoResponse, error)
	GetSystemInfo(context.Context, *types.Empty) (*SystemInfo, error)
	GetAvailableStreams(*GetAvailableStreamsRequest, Telemetry_GetAvailableStreamsServer) error
	GetStream(*GetStreamRequest, Telemetry_GetStreamServer) error
	GetAvailableProperties(*GetAvailablePropertiesRequest, Telemetry_GetAvailablePropertiesServer) error
	GetProperty(*GetPropertyRequest, Telemetry_GetPropertyServer) error
	GetDebug(context.Context, *types.Empty) (*TelemetryDebug, error)
}

// UnimplementedTelemetryServer can be embedded to have forward compatible implementations.
type UnimplementedTelemetryServer struct {
}

func (*UnimplementedTelemetryServer) GetSessionInfo(ctx context.Context, req *types.Empty) (*GetSessionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionInfo not implemented")
}
func (*UnimplementedTelemetryServer) GetSystemInfo(ctx context.Context, req *types.Empty) (*SystemInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (*UnimplementedTelemetryServer) GetAvailableStreams(req *GetAvailableStreamsRequest, srv Telemetry_GetAvailableStreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAvailableStreams not implemented")
}
func (*UnimplementedTelemetryServer) GetStream(req *GetStreamRequest, srv Telemetry_GetStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetStream not implemented")
}
func (*UnimplementedTelemetryServer) GetAvailableProperties(req *GetAvailablePropertiesRequest, srv Telemetry_GetAvailablePropertiesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAvailableProperties not implemented")
}
func (*UnimplementedTelemetryServer) GetProperty(req *GetPropertyRequest, srv Telemetry_GetPropertyServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProperty not implemented")
}
func (*UnimplementedTelemetryServer) GetDebug(ctx context.Context, req *types.Empty) (*TelemetryDebug, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDebug not implemented")
}

func RegisterTelemetryServer(s *grpc.Server, srv TelemetryServer) {
	s.RegisterService(&_Telemetry_serviceDesc, srv)
}

func _Telemetry_GetSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).GetSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/GetSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).GetSessionInfo(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).GetSystemInfo(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_GetAvailableStreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAvailableStreamsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TelemetryServer).GetAvailableStreams(m, &telemetryGetAvailableStreamsServer{stream})
}

type Telemetry_GetAvailableStreamsServer interface {
	Send(*AvailableStream) error
	grpc.ServerStream
}

type telemetryGetAvailableStreamsServer struct {
	grpc.ServerStream
}

func (x *telemetryGetAvailableStreamsServer) Send(m *AvailableStream) error {
	return x.ServerStream.SendMsg(m)
}

func _Telemetry_GetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TelemetryServer).GetStream(m, &telemetryGetStreamServer{stream})
}

type Telemetry_GetStreamServer interface {
	Send(*StreamSegment) error
	grpc.ServerStream
}

type telemetryGetStreamServer struct {
	grpc.ServerStream
}

func (x *telemetryGetStreamServer) Send(m *StreamSegment) error {
	return x.ServerStream.SendMsg(m)
}

func _Telemetry_GetAvailableProperties_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAvailablePropertiesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TelemetryServer).GetAvailableProperties(m, &telemetryGetAvailablePropertiesServer{stream})
}

type Telemetry_GetAvailablePropertiesServer interface {
	Send(*AvailableProperty) error
	grpc.ServerStream
}

type telemetryGetAvailablePropertiesServer struct {
	grpc.ServerStream
}

func (x *telemetryGetAvailablePropertiesServer) Send(m *AvailableProperty) error {
	return x.ServerStream.SendMsg(m)
}

func _Telemetry_GetProperty_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPropertyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TelemetryServer).GetProperty(m, &telemetryGetPropertyServer{stream})
}

type Telemetry_GetPropertyServer interface {
	Send(*PropertySegment) error
	grpc.ServerStream
}

type telemetryGetPropertyServer struct {
	grpc.ServerStream
}

func (x *telemetryGetPropertyServer) Send(m *PropertySegment) error {
	return x.ServerStream.SendMsg(m)
}

func _Telemetry_GetDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).GetDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/GetDebug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).GetDebug(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Telemetry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.Telemetry",
	HandlerType: (*TelemetryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSessionInfo",
			Handler:    _Telemetry_GetSessionInfo_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _Telemetry_GetSystemInfo_Handler,
		},
		{
			MethodName: "GetDebug",
			Handler:    _Telemetry_GetDebug_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAvailableStreams",
			Handler:       _Telemetry_GetAvailableStreams_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetStream",
			Handler:       _Telemetry_GetStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAvailableProperties",
			Handler:       _Telemetry_GetAvailableProperties_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProperty",
			Handler:       _Telemetry_GetProperty_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb/telemetry.proto",
}

func (m *SystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Numcpu != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Numcpu))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Arch) > 0 {
		i -= len(m.Arch)
		copy(dAtA[i:], m.Arch)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Arch)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Os) > 0 {
		i -= len(m.Os)
		copy(dAtA[i:], m.Os)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Os)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastRefresh != nil {
		{
			size, err := m.LastRefresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Peer) > 0 {
		i -= len(m.Peer)
		copy(dAtA[i:], m.Peer)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Peer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryDebug) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryDebug) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryDebug) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryDebug_Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryDebug_Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryDebug_Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seqn != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Seqn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSessionInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSessionInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSessionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BootTime != nil {
		{
			size, err := m.BootTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Session) > 0 {
		i -= len(m.Session)
		copy(dAtA[i:], m.Session)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Session)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAvailableStreamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAvailableStreamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAvailableStreamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AvailableStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailableStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvailableStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Period != nil {
		{
			size, err := m.Period.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keepalive != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Keepalive))
		i--
		dAtA[i] = 0x18
	}
	if m.Seqn != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Seqn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAvailablePropertiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAvailablePropertiesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAvailablePropertiesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AvailableProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailableProperty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvailableProperty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPropertyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPropertyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPropertyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Property) > 0 {
		i -= len(m.Property)
		copy(dAtA[i:], m.Property)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Property)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertySegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertySegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertySegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SystemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Arch)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Numcpu != 0 {
		n += 1 + sovTelemetry(uint64(m.Numcpu))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.LastRefresh != nil {
		l = m.LastRefresh.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryDebug) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryDebug_Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Used != 0 {
		n += 1 + sovTelemetry(uint64(m.Used))
	}
	if m.Total != 0 {
		n += 1 + sovTelemetry(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seqn != 0 {
		n += 1 + sovTelemetry(uint64(m.Seqn))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSessionInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Session)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.BootTime != nil {
		l = m.BootTime.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAvailableStreamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AvailableStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Period != nil {
		l = m.Period.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Seqn != 0 {
		n += 1 + sovTelemetry(uint64(m.Seqn))
	}
	if m.Keepalive != 0 {
		n += 1 + sovTelemetry(uint64(m.Keepalive))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAvailablePropertiesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AvailableProperty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPropertyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Property)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertySegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numcpu", wireType)
			}
			m.Numcpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numcpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer[:0], dAtA[iNdEx:postIndex]...)
			if m.Peer == nil {
				m.Peer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRefresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRefresh == nil {
				m.LastRefresh = &types.Timestamp{}
			}
			if err := m.LastRefresh.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryDebug) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryDebug: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryDebug: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &TelemetryDebug_Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryDebug_Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqn", wireType)
			}
			m.Seqn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSessionInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSessionInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSessionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Session = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BootTime == nil {
				m.BootTime = &types.Timestamp{}
			}
			if err := m.BootTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAvailableStreamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAvailableStreamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAvailableStreamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailableStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailableStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailableStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Period == nil {
				m.Period = &types.Duration{}
			}
			if err := m.Period.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqn", wireType)
			}
			m.Seqn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keepalive", wireType)
			}
			m.Keepalive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keepalive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAvailablePropertiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAvailablePropertiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAvailablePropertiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailableProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailableProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailableProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPropertyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPropertyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPropertyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Property = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertySegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertySegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertySegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)
